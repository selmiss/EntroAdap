"""
Convert nucleic acid sequences (DNA/RNA) to structural features and graph representation.
Uses X3DNA fiber to generate 3D structures from sequences.
"""

import os
import sys
import importlib.util
import numpy as np
from pathlib import Path
from typing import Optional, Dict, Literal, Tuple, List
from scipy.spatial import cKDTree

# Add project root to path
project_root = Path(__file__).resolve().parents[3]
sys.path.insert(0, str(project_root))

# Import 3dna functions
import importlib.util
spec = importlib.util.spec_from_file_location("x3dna_test", str(project_root / "examples" / "3dna_test.py"))
x3dna_test = importlib.util.module_from_spec(spec)
spec.loader.exec_module(x3dna_test)
nucleic_acid_to_coords_or_cif = x3dna_test.nucleic_acid_to_coords_or_cif


# Nucleotide vocabulary mappings
DNA_NUCLEOTIDES = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
RNA_NUCLEOTIDES = {'A': 0, 'C': 1, 'G': 2, 'U': 3}

# Atomic numbers for common atoms in nucleic acids
ELEMENT_TO_ATOMIC_NUM = {
    'H': 1, 'C': 6, 'N': 7, 'O': 8, 'P': 15, 'S': 16
}

# Common atom names in nucleic acids
ATOM_NAME_VOCAB = [
    "P", "OP1", "OP2", "O5'", "C5'", "C4'", "O4'", "C3'", "O3'", "C2'", "O2'", "C1'",
    "N1", "C2", "O2", "N2", "N3", "C4", "O4", "N4", "C5", "C6", "N6", "N7", "C8", "N9",
    "O6", "C7", "H", "other"
]
ATOM_NAME_TO_IDX = {name: idx for idx, name in enumerate(ATOM_NAME_VOCAB)}

# Nucleotide residue names
NUCLEOTIDE_VOCAB = [
    "A", "C", "G", "T", "U",  # Standard nucleotides
    "DA", "DC", "DG", "DT",    # DNA nucleotides (alternative naming)
    "other"
]
NUCLEOTIDE_TO_IDX = {name: idx for idx, name in enumerate(NUCLEOTIDE_VOCAB)}


def is_backbone_atom(atom_name: str) -> bool:
    """Check if atom is part of the nucleotide backbone (sugar-phosphate)."""
    backbone_atoms = {"P", "OP1", "OP2", "O5'", "C5'", "C4'", "O4'", "C3'", "O3'", "C2'", "O2'", "C1'"}
    return atom_name in backbone_atoms


def is_phosphate_atom(atom_name: str) -> bool:
    """Check if atom is part of the phosphate group."""
    phosphate_atoms = {"P", "OP1", "OP2"}
    return atom_name in phosphate_atoms


def parse_pdb_atoms(pdb_path: str) -> Tuple[List[Dict], np.ndarray]:
    """
    Parse ATOM/HETATM records from PDB file generated by X3DNA fiber.
    
    Args:
        pdb_path: Path to PDB file
        
    Returns:
        Tuple of (atom_info_list, coordinates)
        - atom_info_list: List of dicts with atom metadata
        - coordinates: (N, 3) array of coordinates
    """
    atom_info_list = []
    coordinates = []
    
    with open(pdb_path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            rec = line[0:6].strip()
            if rec not in {"ATOM", "HETATM"}:
                continue
            
            atom_name = line[12:16].strip()
            res_name = line[17:20].strip()
            chain_id = (line[21:22].strip() or "A")
            res_id = line[22:26].strip()
            
            try:
                x = float(line[30:38])
                y = float(line[38:46])
                z = float(line[46:54])
            except ValueError:
                continue
            
            element = (line[76:78].strip() if len(line) >= 78 else "")
            if not element:
                # Try to infer element from atom name
                element = atom_name[0] if atom_name else ""
            
            atom_info = {
                'atom_name': atom_name,
                'residue_name': res_name,
                'chain_id': chain_id,
                'residue_id': res_id,
                'element': element
            }
            
            atom_info_list.append(atom_info)
            coordinates.append((x, y, z))
    
    if not coordinates:
        raise RuntimeError(f"No ATOM/HETATM records parsed from {pdb_path}")
    
    coordinates = np.array(coordinates, dtype=np.float32)
    
    # Center coordinates
    coordinates = coordinates - coordinates.mean(axis=0)
    
    return atom_info_list, coordinates


def atom_info_to_features(atom_info_list: List[Dict]) -> np.ndarray:
    """
    Convert atom information to feature matrix for nucleic acids.
    
    Feature order (matching protein features where possible):
    0. atomic_number (119 vocab)
    1. atom_name (len(ATOM_NAME_VOCAB) vocab)
    2. residue (nucleotide type, len(NUCLEOTIDE_VOCAB) vocab)
    3. chain (27 vocab, matching protein)
    4. residue_id (continuous, not categorical)
    5. is_backbone (2 vocab)
    6. is_phosphate (2 vocab)
    
    Args:
        atom_info_list: List of dicts with atom metadata
        
    Returns:
        node_feat: (N, 7) array of integer features
    """
    num_atoms = len(atom_info_list)
    node_feat = np.zeros((num_atoms, 7), dtype=np.int64)
    
    for i, atom in enumerate(atom_info_list):
        # Feature 0: Atomic number
        element = atom['element'].upper()
        atomic_num = ELEMENT_TO_ATOMIC_NUM.get(element, 0)  # 0 for unknown
        node_feat[i, 0] = atomic_num
        
        # Feature 1: Atom name
        atom_name = atom['atom_name']
        atom_idx = ATOM_NAME_TO_IDX.get(atom_name, len(ATOM_NAME_VOCAB) - 1)  # last index for "other"
        node_feat[i, 1] = atom_idx
        
        # Feature 2: Residue (nucleotide type)
        res_name = atom['residue_name'].strip().upper()
        # Map alternative DNA names to standard names
        if res_name.startswith('D'):
            res_name = res_name[1:]  # DA -> A, DC -> C, etc.
        res_idx = NUCLEOTIDE_TO_IDX.get(res_name, len(NUCLEOTIDE_VOCAB) - 1)  # last index for "other"
        node_feat[i, 2] = res_idx
        
        # Feature 3: Chain
        chain = atom['chain_id'].strip()
        if not chain:
            chain_idx = 0
        else:
            # A=1, B=2, ..., Z=26, other=0
            chain_idx = ord(chain[0].upper()) - ord('A') + 1 if len(chain) == 1 and chain[0].isalpha() else 0
            chain_idx = min(chain_idx, 26)  # Cap at 26
        node_feat[i, 3] = chain_idx
        
        # Feature 4: Residue ID (continuous)
        try:
            res_id = int(atom['residue_id'])
        except (ValueError, TypeError):
            res_id = 0
        node_feat[i, 4] = res_id
        
        # Feature 5: Is backbone
        node_feat[i, 5] = 1 if is_backbone_atom(atom_name) else 0
        
        # Feature 6: Is phosphate
        node_feat[i, 6] = 1 if is_phosphate_atom(atom_name) else 0
    
    return node_feat


def build_radius_graph(
    coordinates: np.ndarray,
    radius: float = 10.0,
    max_neighbors: int = 32,
    sym_mode: Literal["union", "mutual"] = "union",
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Build radius graph from coordinates.
    Same implementation as protein pipeline.
    
    Args:
        coordinates: (N, 3) float array
        radius: cutoff distance
        max_neighbors: number of nearest neighbors queried per node
        sym_mode: "union" or "mutual"
        
    Returns:
        edge_index: (2, E) int64
        edge_attr: (E, 1) float32 distances
    """
    if coordinates is None or len(coordinates) == 0:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    coords = np.ascontiguousarray(coordinates, dtype=np.float32)
    n = coords.shape[0]
    if n <= 1:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    if max_neighbors is None:
        raise ValueError("max_neighbors cannot be None")
    
    k = int(max_neighbors)
    if k <= 0:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    tree = cKDTree(coords)
    k_query = min(k + 1, n)
    dists, nbrs = tree.query(coords, k=k_query)
    
    if k_query == 1:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    dists = dists[:, 1:]
    nbrs = nbrs[:, 1:]
    
    valid = np.isfinite(dists) & (dists <= float(radius))
    if not np.any(valid):
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    src = np.repeat(np.arange(n, dtype=np.int64), k_query - 1)[valid.reshape(-1)]
    dst = nbrs.reshape(-1).astype(np.int64, copy=False)[valid.reshape(-1)]
    dist = dists.reshape(-1).astype(np.float32, copy=False)[valid.reshape(-1)]
    
    in_range = (dst >= 0) & (dst < n) & (src != dst)
    src, dst, dist = src[in_range], dst[in_range], dist[in_range]
    if src.size == 0:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    key_dir = src.astype(np.int64) * n + dst.astype(np.int64)
    
    if sym_mode == "mutual":
        key_sorted = np.sort(key_dir)
        rev = dst.astype(np.int64) * n + src.astype(np.int64)
        pos = np.searchsorted(key_sorted, rev)
        ok = (pos < key_sorted.size) & (key_sorted[pos] == rev)
        src, dst, dist = src[ok], dst[ok], dist[ok]
        if src.size == 0:
            return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    a = np.minimum(src, dst)
    b = np.maximum(src, dst)
    key_undir = a.astype(np.int64) * n + b.astype(np.int64)
    
    order = np.argsort(key_undir)
    key_undir = key_undir[order]
    a = a[order]
    b = b[order]
    dist = dist[order]
    
    uniq_mask = np.ones_like(key_undir, dtype=bool)
    uniq_mask[1:] = key_undir[1:] != key_undir[:-1]
    a = a[uniq_mask]
    b = b[uniq_mask]
    dist = dist[uniq_mask]
    
    pairs = np.stack([a, b], axis=1).astype(np.int64, copy=False)
    edge_index = np.concatenate([pairs, pairs[:, [1, 0]]], axis=0).T
    edge_attr = np.concatenate([dist, dist], axis=0).reshape(-1, 1).astype(np.float32, copy=False)
    
    return edge_index, edge_attr


def sequence_to_features(
    seq: str,
    seq_id: str,
    seq_type: Literal["dna", "rna", "auto"] = "auto",
    workdir: str = "./x3dna_workdir",
    graph_radius: float = 8.0,
    max_neighbors: int = 24,
    max_seq_length: int = 500,
    fiber_exe: str = "fiber",
    rna_single_strand: bool = True,
) -> Optional[Dict]:
    """
    Convert nucleic acid sequence to structural features and graph representation.
    
    This function:
    1. Uses X3DNA fiber to generate 3D structure
    2. Parses PDB file to extract atom information
    3. Generates feature vectors for atoms
    4. Builds radius graph for spatial relationships
    
    Args:
        seq: Nucleic acid sequence (DNA or RNA)
        seq_id: Identifier for this sequence
        seq_type: "dna", "rna", or "auto" (auto-detects based on T vs U)
        workdir: Working directory for temporary files
        graph_radius: Distance threshold for edge creation in Angstroms
        max_neighbors: Max neighbors per node
        max_seq_length: Maximum sequence length (will truncate longer sequences)
        fiber_exe: Path to X3DNA fiber executable
        rna_single_strand: Generate RNA as single-stranded (default: True, biologically correct)
        
    Returns:
        Dictionary with keys:
            - 'modality': str - "dna" or "rna"
            - 'seq_id': str - Sequence identifier
            - 'sequence': str - Original sequence
            - 'seq_length': int - Length of sequence
            - 'num_atoms': int - Number of atoms
            - 'node_feat': np.ndarray [num_atoms, 7] - Atom feature matrix
            - 'coordinates': np.ndarray [num_atoms, 3] - 3D coordinates
            - 'edge_index': np.ndarray [2, num_edges] - Graph connectivity
            - 'edge_attr': np.ndarray [num_edges, 1] - Edge distances
        Returns None if processing fails
    """
    # Limit sequence length for fiber (it has issues with very long sequences)
    if len(seq) > max_seq_length:
        # Truncate sequence
        seq = seq[:max_seq_length]
    
    # Step 1: Generate 3D structure using X3DNA fiber
    try:
        result = nucleic_acid_to_coords_or_cif(
            seq=seq,
            seq_type=seq_type,
            workdir=workdir,
            write_cif=False,
            fiber_exe=fiber_exe,
            rna_single_strand=rna_single_strand,
        )
        detected_type = result['seq_type']
        pdb_path = result['pdb_path']
    except Exception as e:
        # Print error for debugging
        print(f"Error generating structure for {seq_id}: {e}")
        return None
    
    # Step 2: Parse PDB file
    try:
        atom_info_list, coordinates = parse_pdb_atoms(pdb_path)
    except Exception as e:
        print(f"Error parsing PDB for {seq_id}: {e}")
        return None
    
    # Step 3: Convert to features
    try:
        node_feat = atom_info_to_features(atom_info_list)
    except Exception as e:
        print(f"Error generating features for {seq_id}: {e}")
        return None
    
    # Step 4: Build radius graph
    try:
        edge_index, edge_attr = build_radius_graph(
            coordinates,
            radius=graph_radius,
            max_neighbors=max_neighbors,
            sym_mode="union"
        )
    except Exception as e:
        print(f"Error building graph for {seq_id}: {e}")
        return None
    
    # Step 5: Package results
    result_dict = {
        'modality': detected_type,
        'seq_id': seq_id,
        'sequence': seq,
        'seq_length': len(seq),
        'num_atoms': len(atom_info_list),
        'node_feat': node_feat,
        'coordinates': coordinates,
        'edge_index': edge_index,
        'edge_attr': edge_attr,
    }
    
    return result_dict


def sequence_to_features_windowed(
    seq: str,
    seq_id: str,
    seq_type: Literal["dna", "rna", "auto"] = "auto",
    workdir: str = "./x3dna_workdir",
    graph_radius: float = 8.0,
    max_neighbors: int = 24,
    window_size: int = 500,
    overlap: int = 50,
    fiber_exe: str = "fiber",
    rna_single_strand: bool = True,
) -> Optional[Dict]:
    """
    Convert long nucleic acid sequence to structural features using sliding windows.
    Windows are merged into a single unified graph structure.
    
    This approach allows processing of sequences longer than X3DNA's ~500nt limit
    for RNA by:
    1. Breaking sequence into overlapping windows
    2. Processing each window with X3DNA fiber
    3. Merging windows into single graph (skipping duplicate overlap regions)
    4. Rebuilding edge connectivity across the full structure
    
    Args:
        seq: Nucleic acid sequence (DNA or RNA)
        seq_id: Identifier for this sequence
        seq_type: "dna", "rna", or "auto" (auto-detects based on T vs U)
        workdir: Working directory for temporary files
        graph_radius: Distance threshold for edge creation in Angstroms
        max_neighbors: Max neighbors per node
        window_size: Size of each window in nucleotides (default: 500)
        overlap: Overlap between consecutive windows in nucleotides (default: 50)
        fiber_exe: Path to X3DNA fiber executable
        rna_single_strand: Generate RNA as single-stranded (default: True, biologically correct)
        
    Returns:
        Dictionary with keys:
            - 'modality': str - "dna" or "rna"
            - 'seq_id': str - Sequence identifier
            - 'sequence': str - Original sequence
            - 'seq_length': int - Length of sequence
            - 'num_atoms': int - Number of atoms
            - 'node_feat': np.ndarray [num_atoms, 7] - Atom feature matrix
            - 'coordinates': np.ndarray [num_atoms, 3] - 3D coordinates
            - 'edge_index': np.ndarray [2, num_edges] - Graph connectivity
            - 'edge_attr': np.ndarray [num_edges, 1] - Edge distances
            - 'num_windows': int - Number of windows processed
        Returns None if processing fails
    """
    import tempfile
    import shutil
    
    # If sequence is short enough, use regular processing
    if len(seq) <= window_size:
        result = sequence_to_features(
            seq=seq,
            seq_id=seq_id,
            seq_type=seq_type,
            workdir=workdir,
            graph_radius=graph_radius,
            max_neighbors=max_neighbors,
            max_seq_length=window_size,
            fiber_exe=fiber_exe,
            rna_single_strand=rna_single_strand,
        )
        if result:
            result['num_windows'] = 1
        return result
    
    # Process sequence in overlapping windows
    windows_data = []
    
    # Create main working directory
    main_workdir = Path(workdir)
    main_workdir.mkdir(parents=True, exist_ok=True)
    
    # Generate windows
    window_positions = []
    for i in range(0, len(seq), window_size - overlap):
        end_pos = min(i + window_size, len(seq))
        if end_pos - i < 100:  # Skip very short terminal windows
            continue
        window_positions.append((i, end_pos))
    
    if not window_positions:
        return None
    
    # Process each window
    for window_idx, (start, end) in enumerate(window_positions):
        window_seq = seq[start:end]
        window_workdir = main_workdir / f"window_{window_idx}"
        window_workdir.mkdir(parents=True, exist_ok=True)
        
        try:
            # Process window
            structure = sequence_to_features(
                seq=window_seq,
                seq_id=f"{seq_id}_window_{window_idx}",
                seq_type=seq_type,
                workdir=str(window_workdir),
                graph_radius=graph_radius,
                max_neighbors=max_neighbors,
                max_seq_length=window_size,
                fiber_exe=fiber_exe,
                rna_single_strand=rna_single_strand,
            )
            
            if structure:
                windows_data.append({
                    'structure': structure,
                    'start_nt': start,
                    'end_nt': end,
                    'seq': window_seq
                })
        except Exception:
            pass  # Skip failed windows
        finally:
            # Clean up window workdir
            if window_workdir.exists():
                shutil.rmtree(window_workdir, ignore_errors=True)
    
    if not windows_data:
        return None
    
    # Merge windows into single structure
    merged_coords = []
    merged_features = []
    atom_offset = 0
    
    for idx, window_data in enumerate(windows_data):
        structure = window_data['structure']
        start_nt = window_data['start_nt']
        
        if idx == 0:
            # First window: take all atoms
            merged_coords.append(structure['coordinates'])
            merged_features.append(structure['node_feat'])
            atom_offset = len(structure['coordinates'])
        else:
            # Subsequent windows: skip overlap region
            prev_end_nt = windows_data[idx-1]['end_nt']
            overlap_nt = prev_end_nt - start_nt
            
            if overlap_nt > 0:
                # Estimate atoms to skip based on atoms per nucleotide
                atoms_per_nt = len(structure['coordinates']) / len(window_data['seq'])
                skip_atoms = int(overlap_nt * atoms_per_nt)
                
                # Take only non-overlapping atoms
                non_overlap_coords = structure['coordinates'][skip_atoms:]
                non_overlap_features = structure['node_feat'][skip_atoms:]
            else:
                # No overlap (shouldn't happen, but handle gracefully)
                non_overlap_coords = structure['coordinates']
                non_overlap_features = structure['node_feat']
            
            merged_coords.append(non_overlap_coords)
            merged_features.append(non_overlap_features)
            atom_offset += len(non_overlap_coords)
    
    # Concatenate all coordinates and features
    final_coords = np.concatenate(merged_coords, axis=0)
    final_features = np.concatenate(merged_features, axis=0)
    
    # Rebuild edge_index from scratch using merged coordinates
    # This ensures consistency and automatically handles inter-window connections
    try:
        edge_index, edge_attr = build_radius_graph(
            coordinates=final_coords,
            radius=graph_radius,
            max_neighbors=max_neighbors,
            sym_mode="union"
        )
    except Exception as e:
        # If graph building fails, return structure without edges
        edge_index = np.empty((2, 0), dtype=np.int64)
        edge_attr = np.empty((0, 1), dtype=np.float32)
    
    # Determine final modality (use first window's detection)
    detected_type = windows_data[0]['structure']['modality']
    
    result_dict = {
        'modality': detected_type,
        'seq_id': seq_id,
        'sequence': seq,
        'seq_length': len(seq),
        'num_atoms': len(final_coords),
        'node_feat': final_features,
        'coordinates': final_coords,
        'edge_index': edge_index,
        'edge_attr': edge_attr,
        'num_windows': len(windows_data)
    }
    
    return result_dict


if __name__ == '__main__':
    # Test with sample sequences
    import tempfile
    import shutil
    
    fiber_exe = os.environ.get("X3DNA_FIBER", "fiber")
    
    print("Testing DNA sequence processing...")
    dna_seq = "ATTCAGATTGCCTCTCATTGTCTCACCC"
    
    with tempfile.TemporaryDirectory() as tmpdir:
        result = sequence_to_features(
            seq=dna_seq,
            seq_id="test_dna",
            seq_type="auto",
            workdir=tmpdir,
            fiber_exe=fiber_exe
        )
        
        if result:
            print(f"✓ Successfully processed DNA sequence")
            print(f"  Modality: {result['modality']}")
            print(f"  Sequence length: {result['seq_length']}")
            print(f"  Number of atoms: {result['num_atoms']}")
            print(f"  Node features shape: {result['node_feat'].shape}")
            print(f"  Coordinates shape: {result['coordinates'].shape}")
            print(f"  Edge index shape: {result['edge_index'].shape}")
            print(f"  Edge attr shape: {result['edge_attr'].shape}")
        else:
            print("✗ Failed to process DNA sequence")
    
    print("\nTesting RNA sequence processing...")
    rna_seq = "AUUCAGAUUGCCUCUCAUUGUCUCACCC"
    
    with tempfile.TemporaryDirectory() as tmpdir:
        result = sequence_to_features(
            seq=rna_seq,
            seq_id="test_rna",
            seq_type="auto",
            workdir=tmpdir,
            fiber_exe=fiber_exe
        )
        
        if result:
            print(f"✓ Successfully processed RNA sequence")
            print(f"  Modality: {result['modality']}")
            print(f"  Sequence length: {result['seq_length']}")
            print(f"  Number of atoms: {result['num_atoms']}")
            print(f"  Node features shape: {result['node_feat'].shape}")
            print(f"  Coordinates shape: {result['coordinates'].shape}")
            print(f"  Edge index shape: {result['edge_index'].shape}")
            print(f"  Edge attr shape: {result['edge_attr'].shape}")
        else:
            print("✗ Failed to process RNA sequence")

