"""
Convert nucleic acid sequences (DNA/RNA) to structural features and graph representation.
Uses X3DNA fiber to generate 3D structures from sequences.
"""

import os
import sys
import importlib.util
import numpy as np
from pathlib import Path
from typing import Optional, Dict, Literal, Tuple, List
from scipy.spatial import cKDTree

# Add project root to path
project_root = Path(__file__).resolve().parents[3]
sys.path.insert(0, str(project_root))

# Import 3dna functions
import importlib.util
spec = importlib.util.spec_from_file_location("x3dna_test", str(project_root / "examples" / "3dna_test.py"))
x3dna_test = importlib.util.module_from_spec(spec)
spec.loader.exec_module(x3dna_test)
nucleic_acid_to_coords_or_cif = x3dna_test.nucleic_acid_to_coords_or_cif


# Nucleotide vocabulary mappings
DNA_NUCLEOTIDES = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
RNA_NUCLEOTIDES = {'A': 0, 'C': 1, 'G': 2, 'U': 3}

# Atomic numbers for common atoms in nucleic acids
ELEMENT_TO_ATOMIC_NUM = {
    'H': 1, 'C': 6, 'N': 7, 'O': 8, 'P': 15, 'S': 16
}

# Common atom names in nucleic acids
ATOM_NAME_VOCAB = [
    "P", "OP1", "OP2", "O5'", "C5'", "C4'", "O4'", "C3'", "O3'", "C2'", "O2'", "C1'",
    "N1", "C2", "O2", "N2", "N3", "C4", "O4", "N4", "C5", "C6", "N6", "N7", "C8", "N9",
    "O6", "C7", "H", "other"
]
ATOM_NAME_TO_IDX = {name: idx for idx, name in enumerate(ATOM_NAME_VOCAB)}

# Nucleotide residue names
NUCLEOTIDE_VOCAB = [
    "A", "C", "G", "T", "U",  # Standard nucleotides
    "DA", "DC", "DG", "DT",    # DNA nucleotides (alternative naming)
    "other"
]
NUCLEOTIDE_TO_IDX = {name: idx for idx, name in enumerate(NUCLEOTIDE_VOCAB)}


def is_backbone_atom(atom_name: str) -> bool:
    """Check if atom is part of the nucleotide backbone (sugar-phosphate)."""
    backbone_atoms = {"P", "OP1", "OP2", "O5'", "C5'", "C4'", "O4'", "C3'", "O3'", "C2'", "O2'", "C1'"}
    return atom_name in backbone_atoms


def is_phosphate_atom(atom_name: str) -> bool:
    """Check if atom is part of the phosphate group."""
    phosphate_atoms = {"P", "OP1", "OP2"}
    return atom_name in phosphate_atoms


def parse_pdb_atoms(pdb_path: str) -> Tuple[List[Dict], np.ndarray]:
    """
    Parse ATOM/HETATM records from PDB file generated by X3DNA fiber.
    
    Args:
        pdb_path: Path to PDB file
        
    Returns:
        Tuple of (atom_info_list, coordinates)
        - atom_info_list: List of dicts with atom metadata
        - coordinates: (N, 3) array of coordinates
    """
    atom_info_list = []
    coordinates = []
    
    with open(pdb_path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            rec = line[0:6].strip()
            if rec not in {"ATOM", "HETATM"}:
                continue
            
            atom_name = line[12:16].strip()
            res_name = line[17:20].strip()
            chain_id = (line[21:22].strip() or "A")
            res_id = line[22:26].strip()
            
            try:
                x = float(line[30:38])
                y = float(line[38:46])
                z = float(line[46:54])
            except ValueError:
                continue
            
            element = (line[76:78].strip() if len(line) >= 78 else "")
            if not element:
                # Try to infer element from atom name
                element = atom_name[0] if atom_name else ""
            
            atom_info = {
                'atom_name': atom_name,
                'residue_name': res_name,
                'chain_id': chain_id,
                'residue_id': res_id,
                'element': element
            }
            
            atom_info_list.append(atom_info)
            coordinates.append((x, y, z))
    
    if not coordinates:
        raise RuntimeError(f"No ATOM/HETATM records parsed from {pdb_path}")
    
    coordinates = np.array(coordinates, dtype=np.float32)
    
    # Center coordinates
    coordinates = coordinates - coordinates.mean(axis=0)
    
    return atom_info_list, coordinates


def atom_info_to_features(atom_info_list: List[Dict]) -> np.ndarray:
    """
    Convert atom information to feature matrix for nucleic acids.
    
    Feature order (matching protein features where possible):
    0. atomic_number (119 vocab)
    1. atom_name (len(ATOM_NAME_VOCAB) vocab)
    2. residue (nucleotide type, len(NUCLEOTIDE_VOCAB) vocab)
    3. chain (27 vocab, matching protein)
    4. residue_id (continuous, not categorical)
    5. is_backbone (2 vocab)
    6. is_phosphate (2 vocab)
    
    Args:
        atom_info_list: List of dicts with atom metadata
        
    Returns:
        node_feat: (N, 7) array of integer features
    """
    num_atoms = len(atom_info_list)
    node_feat = np.zeros((num_atoms, 7), dtype=np.int64)
    
    for i, atom in enumerate(atom_info_list):
        # Feature 0: Atomic number
        element = atom['element'].upper()
        atomic_num = ELEMENT_TO_ATOMIC_NUM.get(element, 0)  # 0 for unknown
        node_feat[i, 0] = atomic_num
        
        # Feature 1: Atom name
        atom_name = atom['atom_name']
        atom_idx = ATOM_NAME_TO_IDX.get(atom_name, len(ATOM_NAME_VOCAB) - 1)  # last index for "other"
        node_feat[i, 1] = atom_idx
        
        # Feature 2: Residue (nucleotide type)
        res_name = atom['residue_name'].strip().upper()
        # Map alternative DNA names to standard names
        if res_name.startswith('D'):
            res_name = res_name[1:]  # DA -> A, DC -> C, etc.
        res_idx = NUCLEOTIDE_TO_IDX.get(res_name, len(NUCLEOTIDE_VOCAB) - 1)  # last index for "other"
        node_feat[i, 2] = res_idx
        
        # Feature 3: Chain
        chain = atom['chain_id'].strip()
        if not chain:
            chain_idx = 0
        else:
            # A=1, B=2, ..., Z=26, other=0
            chain_idx = ord(chain[0].upper()) - ord('A') + 1 if len(chain) == 1 and chain[0].isalpha() else 0
            chain_idx = min(chain_idx, 26)  # Cap at 26
        node_feat[i, 3] = chain_idx
        
        # Feature 4: Residue ID (continuous)
        try:
            res_id = int(atom['residue_id'])
        except (ValueError, TypeError):
            res_id = 0
        node_feat[i, 4] = res_id
        
        # Feature 5: Is backbone
        node_feat[i, 5] = 1 if is_backbone_atom(atom_name) else 0
        
        # Feature 6: Is phosphate
        node_feat[i, 6] = 1 if is_phosphate_atom(atom_name) else 0
    
    return node_feat


def build_radius_graph(
    coordinates: np.ndarray,
    radius: float = 10.0,
    max_neighbors: int = 32,
    sym_mode: Literal["union", "mutual"] = "union",
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Build radius graph from coordinates.
    Same implementation as protein pipeline.
    
    Args:
        coordinates: (N, 3) float array
        radius: cutoff distance
        max_neighbors: number of nearest neighbors queried per node
        sym_mode: "union" or "mutual"
        
    Returns:
        edge_index: (2, E) int64
        edge_attr: (E, 1) float32 distances
    """
    if coordinates is None or len(coordinates) == 0:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    coords = np.ascontiguousarray(coordinates, dtype=np.float32)
    n = coords.shape[0]
    if n <= 1:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    if max_neighbors is None:
        raise ValueError("max_neighbors cannot be None")
    
    k = int(max_neighbors)
    if k <= 0:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    tree = cKDTree(coords)
    k_query = min(k + 1, n)
    dists, nbrs = tree.query(coords, k=k_query)
    
    if k_query == 1:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    dists = dists[:, 1:]
    nbrs = nbrs[:, 1:]
    
    valid = np.isfinite(dists) & (dists <= float(radius))
    if not np.any(valid):
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    src = np.repeat(np.arange(n, dtype=np.int64), k_query - 1)[valid.reshape(-1)]
    dst = nbrs.reshape(-1).astype(np.int64, copy=False)[valid.reshape(-1)]
    dist = dists.reshape(-1).astype(np.float32, copy=False)[valid.reshape(-1)]
    
    in_range = (dst >= 0) & (dst < n) & (src != dst)
    src, dst, dist = src[in_range], dst[in_range], dist[in_range]
    if src.size == 0:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    key_dir = src.astype(np.int64) * n + dst.astype(np.int64)
    
    if sym_mode == "mutual":
        key_sorted = np.sort(key_dir)
        rev = dst.astype(np.int64) * n + src.astype(np.int64)
        pos = np.searchsorted(key_sorted, rev)
        ok = (pos < key_sorted.size) & (key_sorted[pos] == rev)
        src, dst, dist = src[ok], dst[ok], dist[ok]
        if src.size == 0:
            return np.empty((2, 0), dtype=np.int64), np.empty((0, 1), dtype=np.float32)
    
    a = np.minimum(src, dst)
    b = np.maximum(src, dst)
    key_undir = a.astype(np.int64) * n + b.astype(np.int64)
    
    order = np.argsort(key_undir)
    key_undir = key_undir[order]
    a = a[order]
    b = b[order]
    dist = dist[order]
    
    uniq_mask = np.ones_like(key_undir, dtype=bool)
    uniq_mask[1:] = key_undir[1:] != key_undir[:-1]
    a = a[uniq_mask]
    b = b[uniq_mask]
    dist = dist[uniq_mask]
    
    pairs = np.stack([a, b], axis=1).astype(np.int64, copy=False)
    edge_index = np.concatenate([pairs, pairs[:, [1, 0]]], axis=0).T
    edge_attr = np.concatenate([dist, dist], axis=0).reshape(-1, 1).astype(np.float32, copy=False)
    
    return edge_index, edge_attr


def sequence_to_features(
    seq: str,
    seq_id: str,
    seq_type: Literal["dna", "rna", "auto"] = "auto",
    workdir: str = "./x3dna_workdir",
    graph_radius: float = 8.0,
    max_neighbors: int = 24,
    max_seq_length: int = 500,
    fiber_exe: str = "fiber"
) -> Optional[Dict]:
    """
    Convert nucleic acid sequence to structural features and graph representation.
    
    This function:
    1. Uses X3DNA fiber to generate 3D structure
    2. Parses PDB file to extract atom information
    3. Generates feature vectors for atoms
    4. Builds radius graph for spatial relationships
    
    Args:
        seq: Nucleic acid sequence (DNA or RNA)
        seq_id: Identifier for this sequence
        seq_type: "dna", "rna", or "auto" (auto-detects based on T vs U)
        workdir: Working directory for temporary files
        graph_radius: Distance threshold for edge creation in Angstroms
        max_neighbors: Max neighbors per node
        max_seq_length: Maximum sequence length (will truncate longer sequences)
        fiber_exe: Path to X3DNA fiber executable
        
    Returns:
        Dictionary with keys:
            - 'modality': str - "dna" or "rna"
            - 'seq_id': str - Sequence identifier
            - 'sequence': str - Original sequence
            - 'seq_length': int - Length of sequence
            - 'num_atoms': int - Number of atoms
            - 'node_feat': np.ndarray [num_atoms, 7] - Atom feature matrix
            - 'coordinates': np.ndarray [num_atoms, 3] - 3D coordinates
            - 'edge_index': np.ndarray [2, num_edges] - Graph connectivity
            - 'edge_attr': np.ndarray [num_edges, 1] - Edge distances
        Returns None if processing fails
    """
    # Limit sequence length for fiber (it has issues with very long sequences)
    if len(seq) > max_seq_length:
        # Truncate sequence
        seq = seq[:max_seq_length]
    
    # Step 1: Generate 3D structure using X3DNA fiber
    try:
        result = nucleic_acid_to_coords_or_cif(
            seq=seq,
            seq_type=seq_type,
            workdir=workdir,
            write_cif=False,
            fiber_exe=fiber_exe
        )
        detected_type = result['seq_type']
        pdb_path = result['pdb_path']
    except Exception as e:
        # Silently return None for failed sequences
        return None
    
    # Step 2: Parse PDB file
    try:
        atom_info_list, coordinates = parse_pdb_atoms(pdb_path)
    except Exception as e:
        print(f"Error parsing PDB for {seq_id}: {e}")
        return None
    
    # Step 3: Convert to features
    try:
        node_feat = atom_info_to_features(atom_info_list)
    except Exception as e:
        print(f"Error generating features for {seq_id}: {e}")
        return None
    
    # Step 4: Build radius graph
    try:
        edge_index, edge_attr = build_radius_graph(
            coordinates,
            radius=graph_radius,
            max_neighbors=max_neighbors,
            sym_mode="union"
        )
    except Exception as e:
        print(f"Error building graph for {seq_id}: {e}")
        return None
    
    # Step 5: Package results
    result_dict = {
        'modality': detected_type,
        'seq_id': seq_id,
        'sequence': seq,
        'seq_length': len(seq),
        'num_atoms': len(atom_info_list),
        'node_feat': node_feat,
        'coordinates': coordinates,
        'edge_index': edge_index,
        'edge_attr': edge_attr,
    }
    
    return result_dict


if __name__ == '__main__':
    # Test with sample sequences
    import tempfile
    import shutil
    
    fiber_exe = os.environ.get("X3DNA_FIBER", "fiber")
    
    print("Testing DNA sequence processing...")
    dna_seq = "ATTCAGATTGCCTCTCATTGTCTCACCC"
    
    with tempfile.TemporaryDirectory() as tmpdir:
        result = sequence_to_features(
            seq=dna_seq,
            seq_id="test_dna",
            seq_type="auto",
            workdir=tmpdir,
            fiber_exe=fiber_exe
        )
        
        if result:
            print(f"✓ Successfully processed DNA sequence")
            print(f"  Modality: {result['modality']}")
            print(f"  Sequence length: {result['seq_length']}")
            print(f"  Number of atoms: {result['num_atoms']}")
            print(f"  Node features shape: {result['node_feat'].shape}")
            print(f"  Coordinates shape: {result['coordinates'].shape}")
            print(f"  Edge index shape: {result['edge_index'].shape}")
            print(f"  Edge attr shape: {result['edge_attr'].shape}")
        else:
            print("✗ Failed to process DNA sequence")
    
    print("\nTesting RNA sequence processing...")
    rna_seq = "AUUCAGAUUGCCUCUCAUUGUCUCACCC"
    
    with tempfile.TemporaryDirectory() as tmpdir:
        result = sequence_to_features(
            seq=rna_seq,
            seq_id="test_rna",
            seq_type="auto",
            workdir=tmpdir,
            fiber_exe=fiber_exe
        )
        
        if result:
            print(f"✓ Successfully processed RNA sequence")
            print(f"  Modality: {result['modality']}")
            print(f"  Sequence length: {result['seq_length']}")
            print(f"  Number of atoms: {result['num_atoms']}")
            print(f"  Node features shape: {result['node_feat'].shape}")
            print(f"  Coordinates shape: {result['coordinates'].shape}")
            print(f"  Edge index shape: {result['edge_index'].shape}")
            print(f"  Edge attr shape: {result['edge_attr'].shape}")
        else:
            print("✗ Failed to process RNA sequence")

